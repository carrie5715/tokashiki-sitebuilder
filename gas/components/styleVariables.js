// 変数CSS出力（variables.css）を分離
// StyleVariables.writeVariablesCss(folderId, cssVars?)
// - folderId: 出力先フォルダID（省略時は ScriptProperties の OUTPUT_CSS_ID を使用）
// - cssVars: マップ（--var-name -> value）。省略時は CommonInfo 内部の cssVars を参照可能なら利用

var StyleVariables = (function () {
	function buildCssText_(varsMap) {
		const ts = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
		const decls = [];
		const extraKeys = Object.keys(varsMap || {});
		for (let i = 0; i < extraKeys.length; i++) {
			const name = String(extraKeys[i] || '').trim();
			let val = varsMap[name];
			if (!name || !/^--[a-z0-9\-]+$/i.test(name)) continue;
			if (val == null || String(val).trim() === '') continue;
			decls.push(`  ${name}: ${String(val).trim()};`);
		}
		const body = decls.length ? `:root {\n${decls.join('\n')}\n}` : ':root {}';
		const header = [
			'/*',
			` * generated by GAS (StyleVariables) ${ts}`,
			' * source: シート「基本設定」および各コンポーネントで追加された variables',
			' */'
		].join('\n');
		const cssText = `${header}\n${body}\n`;
		const count = (cssText.match(/--[a-z0-9\-]+:/gi) || []).length;
		return { cssText, count };
	}

	function writeVariablesCss(folderId, overrideVars) {
		try {
			if (typeof Utils !== 'undefined' && Utils.logToSheet) {
				Utils.logToSheet('>>>>> スタイル変数出力開始 >>>>>', 'StyleVariables');
			}
			let cssFolderId = folderId;
			if (!cssFolderId) {
				const props = PropertiesService.getScriptProperties();
				cssFolderId = props.getProperty(PROP_KEYS.OUTPUT_CSS_ID);
			}
			if (!cssFolderId) throw new Error('CSS 出力フォルダIDが不明です。Build.checkDirectories() 実行後に呼び出してください。');

			// vars の取得: 引数優先、なければ CommonInfo 内部の cssVars にフォールバック
			let varsMap = overrideVars;
			if (!varsMap && typeof cssVars !== 'undefined') {
				varsMap = cssVars;
			}
			varsMap = varsMap || {};

			const built = buildCssText_(varsMap);
			const folder = DriveApp.getFolderById(cssFolderId);
			const filename = 'variables.css';
			const it = folder.getFilesByName(filename);
			if (it.hasNext()) {
				const file = it.next();
				file.setContent(built.cssText);
			} else {
				const blob = Utilities.newBlob(built.cssText, 'text/css', filename);
				folder.createFile(blob);
			}

			if (typeof Utils !== 'undefined' && Utils.logToSheet) {
				Utils.logToSheet(`variables.css を出力しました（変数 ${built.count} 件）`, 'StyleVariables');
			}
			return { filename: filename, count: built.count };
		} catch (e) {
			if (typeof Utils !== 'undefined' && Utils.logToSheet) {
				Utils.logToSheet(`variables.css 出力エラー: ${e.message}`, 'StyleVariables');
			}
			throw e;
		}
	}

	// theme_styles シートから mq_* 指定のスタイル変数を抽出し、variables.css へ出力
		// 仕様（簡略版フォーマットに対応）:
		// - 1行目: D列以降で mq_* ヘッダが現れる（例: G1= mq_SP, K1= mq_PC ...）。空白で打ち切らず全行を走査
		// - 各 mq_* ブロックはヘッダ列から右に4列（fs, fw, lh, ls）を持つ前提
		// - 2行目: グループキー（例: sp, pc）。ヘッダ列（mq_*）の直下（行2）のセルに格納
		// - データ行は3行目から。C列の識別子（例: --header-company-name）を用い、
		//   変数名 "<id>-<group>-<propKey>" へ各値を出力
	//   propKey は fs( font-size ), fw( font-weight ), lh( line-height ), ls( letter-spacing )
	function exportThemeStylesVariables(folderId) {
		const ss = SpreadsheetApp.getActive();
		const sh = ss.getSheetByName('theme_styles');
		if (typeof Utils !== 'undefined' && Utils.logToSheet) {
			Utils.logToSheet('theme_styles 変数抽出開始', 'StyleVariables');
		}
		if (!sh) {
			if (typeof Utils !== 'undefined' && Utils.logToSheet) {
				Utils.logToSheet('theme_styles シートが見つかりません', 'StyleVariables');
			}
			throw new Error('theme_styles シートが存在しません');
		}
		const values = sh.getDataRange().getValues();
		if (!values || !values.length) return { count: 0 };

		const ROW_HEADER_1 = 0; // 1行目: mq_* ヘッダ
		const ROW_HEADER_2 = 1; // 2行目: グループキー（sp/pc等）
		const ROW_DATA_START = 2; // 3行目以降: データ行開始（簡略版）
		const COL_ID = 2; // C列 index

		const propKeyMap = {
			'font-size': 'fs',
			'font-weight': 'fw',
			'line-height': 'lh',
			'letter-spacing': 'ls'
		};

		// 1行目 D列以降の mq_* ヘッダを検出（空白でも走査継続）
		let lastCol = values[0].length;
		const startCol = 3; // D列 index
		const SEP_RE = /^(\|+|---+|props|mq_sep)$/i;
		const mqHeaders = []; // { label, col, groupKey }
		let sepCol = null;
		let lastHeaderCol = null;
		for (let c = startCol; c < lastCol; c++) {
			const h1raw = values[ROW_HEADER_1][c];
			const h1 = String(h1raw == null ? '' : h1raw).trim();
			// 区切り: 空白 or マーカー
			if (!h1 || SEP_RE.test(h1)) { sepCol = c; break; }
			if (/^mq_/i.test(h1)) {
				const groupKey = String(values[ROW_HEADER_2][c] || '').trim();
				mqHeaders.push({ label: h1, col: c, groupKey: groupKey });
				lastHeaderCol = c;
			} else {
				// mq_* 以外が現れたらヘッダ領域終端とみなす
				sepCol = c; break;
			}
		}
		if (!mqHeaders.length) {
			if (typeof Utils !== 'undefined' && Utils.logToSheet) {
				Utils.logToSheet('mq_* ヘッダが見つかりません', 'StyleVariables');
			}
			return { count: 0 };
		}

		// プロパティ領域の開始列: セパレーターの次列（明示がない場合は最後のヘッダの次列）
		const propStartCol = (sepCol != null) ? (sepCol + 1) : ((lastHeaderCol != null) ? (lastHeaderCol + 1) : startCol);
		const mqPropCols = {}; // { 'mq_SP': { 'font-size': colIndex, ... }, ... }
		// プロパティ領域で、各 mq_* ラベル列を探し、そこを基点に fs/fw/lh/ls を割り当て
		for (let c = propStartCol; c < lastCol; c++) {
			const h1 = String(values[ROW_HEADER_1][c] || '').trim();
			if (!/^mq_/i.test(h1)) continue;
			const cols = {
				'font-size': c,
				'font-weight': c + 1,
				'line-height': c + 2,
				'letter-spacing': c + 3
			};
			const overflow = Object.values(cols).some(cc => cc >= lastCol);
			if (overflow) {
				const msg = `theme_styles の列構成が不正です（${h1} のプロパティ列が不足または範囲外）`;
				if (typeof Utils !== 'undefined' && Utils.logToSheet) { Utils.logToSheet(msg, 'StyleVariables'); }
				throw new Error(msg);
			}
			mqPropCols[h1] = cols;
		}
		// 必要な mq_* に対するプロパティ列が存在するか検証
		mqHeaders.forEach(h => {
			if (!mqPropCols[h.label]) {
				const msg = `theme_styles の列構成が不正です（プロパティ領域に ${h.label} が見つかりません）`;
				if (typeof Utils !== 'undefined' && Utils.logToSheet) { Utils.logToSheet(msg, 'StyleVariables'); }
				throw new Error(msg);
			}
		});

		// グループキーの検証（空は不可）
		mqHeaders.forEach(h => {
			if (!String(h.groupKey || '').trim()) {
				const msg = `theme_styles のグループキーが空です（${h.label} の2行目）`;
				if (typeof Utils !== 'undefined' && Utils.logToSheet) { Utils.logToSheet(msg, 'StyleVariables'); }
				throw new Error(msg);
			}
		});

		// 変数生成
		let outVars = {};
		for (let r = ROW_DATA_START; r < values.length; r++) {
			const id = String(values[r][COL_ID] || '').trim();
			if (!id) continue;
			for (let i = 0; i < mqHeaders.length; i++) {
				const { label, groupKey } = mqHeaders[i];
				const propCols = mqPropCols[label] || {};
				// 対象プロパティごとに出力
				for (const propName in propKeyMap) {
					const key = propKeyMap[propName];
					const colIdx = propCols[propName];
					if (typeof colIdx !== 'number') continue; // 対応列なし
					const valRaw = values[r][colIdx];
					const val = (valRaw == null) ? '' : String(valRaw).trim();
					if (!val) continue;
					const varName = `${id}-${groupKey}-${key}`;
					outVars[varName] = val;
				}
			}
		}

		// 既存の cssVars に結合して出力（フォールバックを含む）
		let merged = {};
		if (typeof cssVars !== 'undefined') {
			Object.keys(cssVars).forEach(k => { merged[k] = cssVars[k]; });
		}
		Object.keys(outVars).forEach(k => { merged[k] = outVars[k]; });

		// 1件も抽出できなければエラー
		const outCount = Object.keys(outVars).length;
		if (!outCount) {
			const msg = 'theme_styles から出力すべき変数が検出されませんでした（フォーマット要確認）';
			if (typeof Utils !== 'undefined' && Utils.logToSheet) { Utils.logToSheet(msg, 'StyleVariables'); }
			throw new Error(msg);
		}

		const res = writeVariablesCss(folderId, merged);
		if (typeof Utils !== 'undefined' && Utils.logToSheet) {
			Utils.logToSheet(`theme_styles 変数出力完了: ${outCount} 件`, 'StyleVariables');
		}
		return { count: outCount, filename: res && res.filename };
	}

	return {
		writeVariablesCss,
		exportThemeStylesVariables,
	};
})();

